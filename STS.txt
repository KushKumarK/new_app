// Java program to for Knight's tour problem using
// Warnsdorff's algorithm
import java.util.concurrent.ThreadLocalRandom;

class GFG
{
	public static final int N = 8;

	// Move pattern on basis of the change of
	// x coordinates and y coordinates respectively
	public static final int cx[] = {1, 1, 2, 2, -1, -1, -2, -2};
	public static final int cy[] = {2, -2, 1, -1, 2, -2, 1, -1};

	// function restricts the knight to remain within
	// the 8x8 chessboard
	boolean limits(int x, int y)
	{
		return ((x >= 0 && y >= 0) &&
				(x < N && y < N));
	}

	/* Checks whether a square is valid and
	empty or not */
	boolean isempty(int a[], int x, int y)
	{
		return (limits(x, y)) && (a[y * N + x] < 0);
	}

	/* Returns the number of empty squares
	adjacent to (x, y) */
	int getDegree(int a[], int x, int y)
	{
		int count = 0;
		for (int i = 0; i < N; ++i)
			if (isempty(a, (x + cx[i]),
						(y + cy[i])))
				count++;

		return count;
	}

	// Picks next point using Warnsdorff's heuristic.
	// Returns false if it is not possible to pick
	// next point.
	Cell nextMove(int a[], Cell cell)
	{
		int min_deg_idx = -1, c,
			min_deg = (N + 1), nx, ny;

		// Try all N adjacent of (*x, *y) starting
		// from a random adjacent. Find the adjacent
		// with minimum degree.
		int start = ThreadLocalRandom.current().nextInt(1000) % N;
		for (int count = 0; count < N; ++count)
		{
			int i = (start + count) % N;
			nx = cell.x + cx[i];
			ny = cell.y + cy[i];
			if ((isempty(a, nx, ny)) &&
				(c = getDegree(a, nx, ny)) < min_deg)
			{
				min_deg_idx = i;
				min_deg = c;
			}
		}

		// IF we could not find a next cell
		if (min_deg_idx == -1)
			return null;

		// Store coordinates of next point
		nx = cell.x + cx[min_deg_idx];
		ny = cell.y + cy[min_deg_idx];

		// Mark next move
		a[ny * N + nx] = a[(cell.y) * N +
						(cell.x)] + 1;

		// Update next point
		cell.x = nx;
		cell.y = ny;

		return cell;
	}

	/* displays the chessboard with all the
	legal knight's moves */
	void print(int a[])
	{
		for (int i = 0; i < N; ++i)
		{
			for (int j = 0; j < N; ++j)
				System.out.printf("%d\t", a[j * N + i]);
			System.out.printf("\n");
		}
	}

	/* checks its neighbouring squares */
	/* If the knight ends on a square that is one
	knight's move from the beginning square,
	then tour is closed */
	boolean neighbour(int x, int y, int xx, int yy)
	{
		for (int i = 0; i < N; ++i)
			if (((x + cx[i]) == xx) &&
				((y + cy[i]) == yy))
				return true;

		return false;
	}

	/* Generates the legal moves using warnsdorff's
	heuristics. Returns false if not possible */
	boolean findClosedTour()
	{
		// Filling up the chessboard matrix with -1's
		int a[] = new int[N * N];
		for (int i = 0; i < N * N; ++i)
			a[i] = -1;

		// initial position
		int sx = 3;
		int sy = 2;

		// Current points are same as initial points
		Cell cell = new Cell(sx, sy);

		a[cell.y * N + cell.x] = 1; // Mark first move.

		// Keep picking next points using
		// Warnsdorff's heuristic
		Cell ret = null;
		for (int i = 0; i < N * N - 1; ++i)
		{
			ret = nextMove(a, cell);
			if (ret == null)
				return false;
		}

		// Check if tour is closed (Can end
		// at starting point)
		if (!neighbour(ret.x, ret.y, sx, sy))
			return false;

		print(a);
		return true;
	}

	// Driver Code
	public static void main(String[] args)
	{
		// While we don't get a solution
		while (!new GFG().findClosedTour())
		{
			;
		}
	}
}

class Cell
{
	int x;
	int y;

	public Cell(int x, int y)
	{
		this.x = x;
		this.y = y;
	}
}

//Bead Sort
public class BeadSort {
	public static void beadSort(int[] a)
	{
		// Find the maximum element
		int max = a[0];
		for (int i = 1; i < a.length; i++) {
			if (a[i] > max) {
				max = a[i];
			}
		}

		// allocating memory
		int[][] beads = new int[a.length][max];

		// mark the beads
		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i]; j++) {
				beads[i][j] = 1;
			}
		}

		// move down the beads
		for (int j = 0; j < max; j++) {
			int sum = 0;
			for (int i = 0; i < a.length; i++) {
				sum += beads[i][j];
				beads[i][j] = 0;
			}

			for (int i = a.length - 1; i >= a.length - sum;
				i--) {
				a[i] = j + 1;
			}
		}
	}

	public static void main(String[] args)
	{
		int[] a = { 4, 2, 6, 1, 8 };
		beadSort(a);
		for (int i : a) {
			System.out.print(i + " ");
		}
	}
}

//Natural Sort Order
import java.util.Comparator;
import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class NaturalOrderComparator implements Comparator<String> {
    private static final NaturalOrderComparator INSTANCE = new NaturalOrderComparator();

    public static NaturalOrderComparator getInstance() {
        return INSTANCE;
    }

    private int compareRight(String a, String b) {
        int bias = 0, ia = 0, ib = 0;
        for (;; ia++, ib++) {
            char ca = charAt(a, ia);
            char cb = charAt(b, ib);

            if (!isDigit(ca) && !isDigit(cb)) {
                return bias;
            }
            if (!isDigit(ca)) {
                return -1;
            }
            if (!isDigit(cb)) {
                return +1;
            }
            if (ca == 0 && cb == 0) {
                return bias;
            }

            if (bias == 0) {
                if (ca < cb) {
                    bias = -1;
                } else if (ca > cb) {
                    bias = +1;
                }
            }
        }
    }

    @Override
    public int compare(String a, String b) {
        int ia = 0, ib = 0;
        int nza = 0, nzb = 0;
        char ca, cb;

        while (true) {
            // Only count the number of zeroes leading the last number compared
            nza = nzb = 0;

            ca = charAt(a, ia);
            cb = charAt(b, ib);

            // Skip leading spaces or zeros
            while (Character.isSpaceChar(ca) || ca == '0') {
                if (ca == '0') {
                    nza++;
                } else {
                    // Only count consecutive zeroes
                    nza = 0;
                }
                ca = charAt(a, ++ia);
            }

            while (Character.isSpaceChar(cb) || cb == '0') {
                if (cb == '0') {
                    nzb++;
                } else {
                    // Only count consecutive zeroes
                    nzb = 0;
                }
                cb = charAt(b, ++ib);
            }

            // Process run of digits
            if (Character.isDigit(ca) && Character.isDigit(cb)) {
                int result = compareRight(a.substring(ia), b.substring(ib));
                if (result != 0) {
                    return result;
                }
            }

            if (ca == 0 && cb == 0) {
                // The two strings are equal when compared naturally
                return nza - nzb;
            }

            if (ca < cb) {
                return -1;
            } else if (ca > cb) {
                return +1;
            }

            // Move to the next characters in both strings
            ca = charAt(a, ++ia);
            cb = charAt(b, ++ib);
        }
    }

    public boolean compareEqual(String a, String b) {
        int ia = 0, ib = 0;
        char ca, cb;

        while (true) {
            ca = charAt(a, ia);
            cb = charAt(b, ib);

            // Skip leading spaces or zeros
            while (Character.isSpaceChar(ca) || ca == '0') {
                ca = charAt(a, ++ia);
            }

            while (Character.isSpaceChar(cb) || cb == '0') {
                cb = charAt(b, ++ib);
            }

            if (ca == 0 && cb == 0) {
                // The two strings are equal when compared naturally
                return true;
            }

            if (ca != cb) {
                // The characters are different, so the strings are not equal
                return false;
            }

            // Move to the next characters in both strings
            ca = charAt(a, ++ia);
            cb = charAt(b, ++ib);
        }
    }

    private static char charAt(String s, int i) {
        return i >= s.length() ? 0 : s.charAt(i);
    }

    private static boolean isDigit(char c) {
        return c >= '0' && c <= '9';
    }

    public static void main(String[] args) {
        List<String> strings = new ArrayList<>();
        strings.add("file002.txt");
        strings.add("file2.txt");
        strings.add("file10.txt");
        strings.add("file1.txt");
        strings.add("file020.txt");
        strings.add("file003.txt");
        strings.add("file 2.txt");
        strings.add("file 1.txt");
        strings.add("file 10.txt");
        strings.add("file20.txt");
        strings.add("");
        strings.add("file1.txt");
        strings.add("");
        strings.add("file20.txt");

        // Sort the list using NaturalOrderComparator
        Collections.sort(strings, NaturalOrderComparator.getInstance());

        // Output the sorted list
        for (String s : strings) {
            System.out.println(s);
        }
    }
}

// Java program to print all permutations of a string
// in sorted order.
import java.io.*;
import java.util.*;

class Solution {

// Calculating factorial of a number
static int factorial(int n) {
	int f = 1;
	for (int i = 1; i <= n; i++)
	f = f * i;
	return f;
}

// Method to print the array
static void print(char[] temp) {
	for (int i = 0; i < temp.length; i++)
	System.out.print(temp[i]);
	System.out.println();
}

// Method to find total number of permutations
static int calculateTotal(char[] temp, int n) {
	int f = factorial(n);

	// Building HashMap to store frequencies of
	// all characters.
	HashMap<Character, Integer> hm =
					new HashMap<Character, Integer>();
	for (int i = 0; i < temp.length; i++) {
	if (hm.containsKey(temp[i]))
		hm.put(temp[i], hm.get(temp[i]) + 1);
	else
		hm.put(temp[i], 1);
	}

	// Traversing hashmap and finding duplicate elements.
	for (Map.Entry e : hm.entrySet()) {
	Integer x = (Integer)e.getValue();
	if (x > 1) {
		int temp5 = factorial(x);
		f = f / temp5;
	}
	}
	return f;
}

static void nextPermutation(char[] temp) {

	// Start traversing from the end and
	// find position 'i-1' of the first character
	// which is greater than its successor.
	int i;
	for (i = temp.length - 1; i > 0; i--)
	if (temp[i] > temp[i - 1])
		break;

	// Finding smallest character after 'i-1' and
	// greater than temp[i-1]
	int min = i;
	int j, x = temp[i - 1];
	for (j = i + 1; j < temp.length; j++)
	if ((temp[j] < temp[min]) && (temp[j] > x))
		min = j;

	// Swapping the above found characters.
	char temp_to_swap;
	temp_to_swap = temp[i - 1];
	temp[i - 1] = temp[min];
	temp[min] = temp_to_swap;

	// Sort all digits from position next to 'i-1'
	// to end of the string.
	Arrays.sort(temp, i, temp.length);

	// Print the String
	print(temp);
}

static void printAllPermutations(String s) {

	// Sorting String
	char temp[] = s.toCharArray();
	Arrays.sort(temp);

	// Print first permutation
	print(temp);

	// Finding the total permutations
	int total = calculateTotal(temp, temp.length);
	for (int i = 1; i < total; i++)
	nextPermutation(temp);
}

// Driver Code
public static void main(String[] args) {
	String s = "AAB";
	printAllPermutations(s);
}
}
// A simple java program to calculate
// Euler's Totient Function
import java.io.*;

class GFG {

	// Function to return GCD of a and b
	static int gcd(int a, int b)
	{
		if (a == 0)
			return b;
		return gcd(b % a, a);
	}

	// A simple method to evaluate
	// Euler Totient Function
	static int phi(int n)
	{
		int result = 1;
		for (int i = 2; i < n; i++)
			if (gcd(i, n) == 1)
				result++;
		return result;
	}

	// Driver code
	public static void main(String[] args)
	{
		int n;

		for (n = 1; n <= 10; n++)
			System.out.println("phi(" + n + ") = " + phi(n));
	}
}

// Java program to calculate Euler's Totient
// Function using Euler's product formula
import java.io.*;

class GFG {
	static int phi(int n)
	{
		// Initialize result as n
		float result = n;

		// Consider all prime factors of n and for
		// every prime factor p, multiply result
		// with (1 - 1/p)
		for (int p = 2; p * p <= n; ++p) {
			// Check if p is a prime factor.
			if (n % p == 0) {
				// If yes, then update n and result
				while (n % p == 0)
					n /= p;
				result *= (1.0 - (1.0 / (float)p));
			}
		}

		// If n has a prime factor greater than sqrt(n)
		// (There can be at-most one such prime factor)
		if (n > 1)
			result -= result / n;
//Since in the set {1,2,....,n-1}, all numbers are relatively prime with n
//if n is a prime number

		return (int)result;
	}

	// Driver program to test above function
	public static void main(String args[])
	{
		int n;
		for (n = 1; n <= 10; n++)
			System.out.println("phi(" + n + ") = " + phi(n));
	}
}

// Java program to print all primes smaller than or equal to
// n using Sieve of Eratosthenes Simple

class SieveOfEratosthenes {
	void sieveOfEratosthenes(int n)
	{
		// Create a boolean array "prime[0..n]" and
		// initialize all entries it as true. A value in
		// prime[i] will finally be false if i is Not a
		// prime, else true.
		boolean prime[] = new boolean[n + 1];
		for (int i = 0; i <= n; i++)
			prime[i] = true;

		for (int p = 2; p * p <= n; p++) {
			// If prime[p] is not changed, then it is a
			// prime
			if (prime[p] == true) {
				// Update all multiples of p greater than or
				// equal to the square of it numbers which
				// are multiple of p and are less than p^2
				// are already been marked.
				for (int i = p * p; i <= n; i += p)
					prime[i] = false;
			}
		}

		// Print all prime numbers
		for (int i = 2; i <= n; i++) {
			if (prime[i] == true)
				System.out.print(i + " ");
		}
	}

	// Driver Code
	public static void main(String args[])
	{
		int n = 30;
		System.out.print("Following are the prime numbers ");
		System.out.println("smaller than or equal to " + n);
		SieveOfEratosthenes g = new SieveOfEratosthenes();
		g.sieveOfEratosthenes(n);
	}
}

// Java program to print all primes smaller than
// n using segmented sieve


import java.util.Vector;
import static java.lang.Math.sqrt;
import static java.lang.Math.floor;

class Test
{
	static void simpleSieve(int limit, Vector<Integer> prime)
	{
		for (int i = 0; i < mark.length; i++)
			mark[i] = true;
	
		for (int p=2; p*p<limit; p++)
		{
			if (mark[p] == true)
			{
				// Update all multiples of p
				for (int i=p*p; i<limit; i+=p)
					mark[i] = false;
			}
		}
		// Print all prime numbers and store them in prime
		for (int p=2; p<limit; p++)
		{
			if (mark[p] == true)
			{
				prime.add(p);
				System.out.print(p + " ");
			}
		}
	}
	
	// Prints all prime numbers smaller than 'n' segmented sieve
	static void segmentedSieve(int n)
	{
		int limit = (int) (floor(sqrt(n))+1);
		Vector<Integer> prime = new Vector<>();
		simpleSieve(limit, prime);
		int low = limit;
		int high = 2*limit;
		while (low < n)
		{
			if (high >= n)
				high = n;
			boolean mark[] = new boolean[limit+1];
			for (int i = 0; i < mark.length; i++)
				mark[i] = true;
			for (int i = 0; i < prime.size(); i++)
			{
				int loLim = (int) (floor(low/prime.get(i)) * prime.get(i));
				if (loLim < low)
					loLim += prime.get(i);
				for (int j=loLim; j<high; j+=prime.get(i))
					mark[j-low] = false;
			}
	
			// Numbers which are not marked as false are prime
			for (int i = low; i<high; i++)
				if (mark[i - low] == true)
					System.out.print(i + " ");
	
			// Update low and high for next segment
			low = low + limit;
			high = high + limit;
		}
	}
	
	// Driver method
	public static void main(String args[])
	{
		int n = 100;
		System.out.println("Primes smaller than " + n + ":");
		segmentedSieve(n);
	}
}

// Java program to print all
// Strobogrammatic number of length n
import java.util.*;

class GFG {

// definition function
static ArrayList<String> numdef(int n, int length)
{
	ArrayList<String> result = new ArrayList<String>();
	if (n == 0)
	return result;
	if (n == 1) {
	result.add("1");
	result.add("0");
	result.add("8");
	return result;
	}

	ArrayList<String> middles = numdef(n - 2, length);

	for (String middle : middles) {
	if (n != length)
		result.add("0" + middle + "0");

	result.add("8" + middle + "8");
	result.add("1" + middle + "1");
	result.add("9" + middle + "6");
	result.add("6" + middle + "9");
	}
	return result;
}

// strobogrammatic function
static ArrayList<String> strobogrammatic_num(int n)
{
	ArrayList<String> result = numdef(n, n);
	return result;
}

// Driver Code
public static void main(String[] args)
{
	// Print all Strobogrammatic
	// number for n = 3
	for (String num : (strobogrammatic_num(3)))
	System.out.print(num + " ");
}
}

// Java program for Alice Apple Tree
import java.io.*;
class GFG {

// Function to minimum no. of apples
static int minApples(int M,int K,int N,int S,int W,int E)
{

	// If we get all required apple
	// from South
	if(M <= S * K)
		return M;

	// If we required trees at
	// East and West
	else if(M <= S * K + E + W)
		return S * K + (M-S * K) * K;

	// If we doesn't have enough
	// red apples
	else
		return -1;
}

// Driver code
public static void main(String[] args)
{
	// No. of red apple for gift
	int M = 10;

	// No. of red apple in each tree
	int K = 15;

	// No. of tree in North
	int N = 0;

	// No. of tree in South
	int S = 1;

	// No. of tree in West
	int W = 0;

	// No. of tree in East
	int E = 0;

	// Function Call
	int ans = minApples(M,K,N,S,W,E);
	System.out.println(ans);
}
}

// Java code to implement booth's algorithm
class GFG
{

	// function to perform adding in the accumulator
	static void add(int ac[], int x[], int qrn)
	{
		int i, c = 0;

		for (i = 0; i < qrn; i++)
		{

			// updating accumulator with A = A + BR
			ac[i] = ac[i] + x[i] + c;

			if (ac[i] > 1)
			{
				ac[i] = ac[i] % 2;
				c = 1;
			}
			else
			{
				c = 0;
			}
		}
	}

	// function to find the number's complement
	static void complement(int a[], int n)
	{
		int i;
		int[] x = new int[8];
		x[0] = 1;

		for (i = 0; i < n; i++)
		{
			a[i] = (a[i] + 1) % 2;
		}
		add(a, x, n);
	}

	// function ro perform right shift
	static void rightShift(int ac[], int qr[],
							int qn, int qrn)
	{
		int temp, i;
		temp = ac[0];
		qn = qr[0];

		System.out.print("\t\trightShift\t");

		for (i = 0; i < qrn - 1; i++)
		{
			ac[i] = ac[i + 1];
			qr[i] = qr[i + 1];
		}
		qr[qrn - 1] = temp;
	}

	// function to display operations
	static void display(int ac[], int qr[], int qrn)
	{
		int i;

		// accumulator content
		for (i = qrn - 1; i >= 0; i--)
		{
			System.out.print(ac[i]);
		}
		System.out.print("\t");

		// multiplier content
		for (i = qrn - 1; i >= 0; i--)
		{
			System.out.print(qr[i]);
		}
	}

	// Function to implement booth's algo
	static void boothAlgorithm(int br[], int qr[], int mt[],
											int qrn, int sc)
	{

		int qn = 0;
		int[] ac = new int[10];
		int temp = 0;
		System.out.print("qn\tq[n+1]\t\tBR\t\tAC\tQR\t\tsc\n");
		System.out.print("\t\t\tinitial\t\t");

		display(ac, qr, qrn);
		System.out.print("\t\t" + sc + "\n");

		while (sc != 0)
		{
			System.out.print(qr[0] + "\t" + qn);

			// SECOND CONDITION
			if ((qn + qr[0]) == 1)
			{
				if (temp == 0)
				{

					// subtract BR from accumulator
					add(ac, mt, qrn);
					System.out.print("\t\tA = A - BR\t");

					for (int i = qrn - 1; i >= 0; i--)
					{
						System.out.print(ac[i]);
					}
					temp = 1;
				}
				
				// THIRD CONDITION
				else if (temp == 1)
				{
					// add BR to accumulator
					add(ac, br, qrn);
					System.out.print("\t\tA = A + BR\t");

					for (int i = qrn - 1; i >= 0; i--)
					{
						System.out.print(ac[i]);
					}
					temp = 0;
				}
				System.out.print("\n\t");
				rightShift(ac, qr, qn, qrn);
			}
			
			// FIRST CONDITION
			else if (qn - qr[0] == 0)
			{
				rightShift(ac, qr, qn, qrn);
			}

			display(ac, qr, qrn);

			System.out.print("\t");

			// decrement counter
			sc--;
			System.out.print("\t" + sc + "\n");
		}
	}

	static void reverse(int a[])
	{
		int i, k, n = a.length;
		int t;
		for (i = 0; i < n / 2; i++)
		{
			t = a[i];
			a[i] = a[n - i - 1];
			a[n - i - 1] = t;
		}
	}
	
	// Driver code
	public static void main(String[] args)
	{
		int[] mt = new int[10];
		int sc;
		int brn, qrn;

		// Number of multiplicand bit
		brn = 4;

		// multiplicand
		int br[] = {0, 1, 1, 0};

		// copy multiplier to temp array mt[]
		for (int i = brn - 1; i >= 0; i--)
		{
			mt[i] = br[i];
		}

		reverse(br);

		complement(mt, brn);

		// No. of multiplier bit
		qrn = 4;

		// sequence counter
		sc = qrn;

		// multiplier
		int qr[] = {1, 0, 1, 0};
		reverse(qr);

		boothAlgorithm(br, qr, mt, qrn, sc);

		System.out.print("\n"
				+ "Result = ");

		for (int i = qrn - 1; i >= 0; i--)
		{
			System.out.print(qr[i]);
		}
	}
}

// A Java program to demonstrate the working of Chinese remainder
// Theorem
import java.io.*;

class GFG {
	
	// k is size of num[] and rem[]. Returns the smallest
	// number x such that:
	// x % num[0] = rem[0],
	// x % num[1] = rem[1],
	// ..................
	// x % num[k-2] = rem[k-1]
	// Assumption: Numbers in num[] are pairwise coprime
	// (gcd for every pair is 1)
	static int findMinX(int num[], int rem[], int k)
	{
		int x = 1; // Initialize result
	
		// As per the Chinese remainder theorem,
		// this loop will always break.
		while (true)
		{
			// Check if remainder of x % num[j] is
			// rem[j] or not (for all j from 0 to k-1)
			int j;
			for (j=0; j<k; j++ )
				if (x%num[j] != rem[j])
				break;
	
			// If all remainders matched, we found x
			if (j == k)
				return x;
	
			// Else try next number
			x++;
		}
	
	}
	
	// Driver method
	public static void main(String args[])
	{
		int num[] = {3, 4, 5};
		int rem[] = {2, 3, 1};
		int k = num.length;
		System.out.println("x is " + findMinX(num, rem, k));
	}
}

// Java code for Block Swap
import java.io.*;

public class GFG {
	static void leftRotate(int arr[], int d, int n)
	{
		int i, j;
		if (d == 0 || d == n)
			return;
		/* If number of elements to be rotated is more than
		* array size*/
		if (d > n)
			d = d % n;
		i = d;
		j = n - d;
		while (i != j) {
			if (i < j) /*A is shorter*/
			{
				swap(arr, d - i, d + j - i, i);
				j -= i;
			}
			else /*B is shorter*/
			{
				swap(arr, d - i, d, j);
				i -= j;
			}
			// printArray(arr, 7);
		}
		/*Finally, block swap A and B*/
		swap(arr, d - i, d, i);
	}

	/*UTILITY FUNCTIONS*/
	/* function to print an array */
	public static void printArray(int arr[], int size)
	{
		int i;
		for (i = 0; i < size; i++)
			System.out.print(arr[i] + " ");
		System.out.println();
	}

	/*This function swaps d elements
	starting at index fi with d elements
	starting at index si */
	public static void swap(int arr[], int fi, int si,
							int d)
	{
		int i, temp;
		for (i = 0; i < d; i++) {
			temp = arr[fi + i];
			arr[fi + i] = arr[si + i];
			arr[si + i] = temp;
		}
	}

	// Driver Code
	public static void main(String[] args)
	{
		int arr[] = { 1, 2, 3, 4, 5, 6, 7 };
		leftRotate(arr, 2, 7);
		printArray(arr, 7);
	}
}

// Java program to demonstrate Basic Euclidean Algorithm

import java.lang.*;
import java.util.*;

class GFG {
	// extended Euclidean Algorithm
	public static int gcd(int a, int b)
	{
		if (a == 0)
			return b;

		return gcd(b % a, a);
	}

	// Driver code
	public static void main(String[] args)
	{
		int a = 10, b = 15, g;
	
		// Function call
		g = gcd(a, b);
		System.out.println("GCD(" + a + " , " + b
						+ ") = " + g);

		a = 35;
		b = 10;
		g = gcd(a, b);
		System.out.println("GCD(" + a + " , " + b
						+ ") = " + g);

		a = 31;
		b = 2;
		g = gcd(a, b);
		System.out.println("GCD(" + a + " , " + b
						+ ") = " + g);
	}
}

//Karatsuba Algorithm
import java.math.BigInteger;
import java.util.Scanner;

public class KaratsubaAlgorithm {
    public static BigInteger karatsuba(BigInteger x, BigInteger y) {
        int n = Math.max(x.bitLength(), y.bitLength());
        // Base case: If numbers are small, use regular multiplication
        if (n <= 2000) {
            return x.multiply(y);
        }

        // Split the input numbers into two halves
        int half = (n + 32) / 64 * 32; // Round up to multiple of 32 to avoid overflow
        BigInteger mask = BigInteger.ONE.shiftLeft(half).subtract(BigInteger.ONE);
        BigInteger xlow = x.and(mask);
        BigInteger ylow = y.and(mask);
        BigInteger xhigh = x.shiftRight(half);
        BigInteger yhigh = y.shiftRight(half);

        // Recursively compute the three intermediate products
        BigInteger a = karatsuba(xhigh, yhigh);
        BigInteger b = karatsuba(xlow.add(xhigh), ylow.add(yhigh));
        BigInteger c = karatsuba(xlow, ylow);

        // Combine the three intermediate products to get the final result
        BigInteger ab = a.shiftLeft(half * 2);
        BigInteger adbc = b.subtract(a).subtract(c).shiftLeft(half);
        return ab.add(adbc).add(c);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the first number: ");
        BigInteger x = scanner.nextBigInteger();

        System.out.print("Enter the second number: ");
        BigInteger y = scanner.nextBigInteger();

        scanner.close();

        BigInteger result = karatsuba(x, y);
        System.out.println("Multiplication result: " + result);
    }
}

//Leaders in an array
import java.util.ArrayList;
import java.util.List;

public class LeadersInArray {
    public static List<Integer> findLeaders(int[] arr) {
        List<Integer> leaders = new ArrayList<>();
        if (arr.length == 0) {
            return leaders;
        }

        int currentLeader = arr[arr.length - 1];
        leaders.add(currentLeader);

        for (int i = arr.length - 2; i >= 0; i--) {
            if (arr[i] > currentLeader) {
                currentLeader = arr[i];
                leaders.add(currentLeader);
            }
        }

        return leaders;
    }

    public static void main(String[] args) {
        int[] arr = {16, 17, 4, 3, 5, 2};

        List<Integer> leaders = findLeaders(arr);

        System.out.println("Leaders in the array: " + leaders);
    }
}

//Lexicographically first string
import java.util.Arrays;
import java.util.Scanner;

public class LexicographicallyFirstPalindrome {
    public static String getLexicographicallyFirstPalindrome(String input) {
        // Convert the input string to a character array and sort it
        char[] chars = input.toCharArray();
        Arrays.sort(chars);

        // Create two strings - one for the left half and one for the right half of the palindrome
        StringBuilder left = new StringBuilder();
        StringBuilder right = new StringBuilder();

        // If the length of the input is odd, the middle character will be used only once
        // So, we add it to the left half and skip it in the right half
        int middleIndex = -1;
        if (chars.length % 2 != 0) {
            middleIndex = chars.length / 2;
            left.append(chars[middleIndex]);
        }

        // Construct the left and right halves of the palindrome
        for (int i = 0; i < chars.length / 2; i++) {
            left.append(chars[i]);
            right.insert(0, chars[chars.length - 1 - i]);
        }

        // Combine left and right halves to form the final palindrome
        StringBuilder palindrome = left.append(right);

        return palindrome.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Enter the input string: ");
        String input = scanner.nextLine();

        scanner.close();

        String palindrome = getLexicographicallyFirstPalindrome(input);
        System.out.println("Lexicographically first palindrome: " + palindrome);
    }
}

//Longest subsequence of 1s with flip
import java.util.Scanner;

public class LongestSubarrayWithOnesAfterReplacement {
    private static int findMaxConsecutiveOnes(int[] a, int k) {
        int maxOnes = 0;
        int numReplacements = 0;
        int windowStart = 0;

        for (int windowEnd = 0; windowEnd < a.length; windowEnd++) {
            if (a[windowEnd] == 0) {
                numReplacements++;
            }

            // If the number of replacements exceeds k, shrink the window from the left
            while (numReplacements > k) {
                if (a[windowStart] == 0) {
                    numReplacements--;
                }
                windowStart++;
            }

            // Update the maximum length of consecutive ones in the window
            maxOnes = Math.max(maxOnes, windowEnd - windowStart + 1);
        }

        return maxOnes;
    }

    public static void main(String[] args) {
        int[] a = {1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0};
        int k = 1;
        int result = findMaxConsecutiveOnes(a, k);
        System.out.printf("Length of longest contiguous subarray containing only 1s after replacement = %d%n", result);
    }
}

// Java program to find maximum consecutive
// 1's in binary representation of a number
// after flipping one bit.

class GFG
{

	static int flipBit(int a)
	{
		/* If all bits are l, binary representation
		of 'a' has all 1s */
		if (~a == 0)
		{
			return 8 * sizeof();
		}

		int currLen = 0, prevLen = 0, maxLen = 0;
		while (a != 0)
		{
			// If Current bit is a 1
			// then increment currLen++
			if ((a & 1) == 1)
			{
				currLen++;
			}
			
			// If Current bit is a 0 then
			// check next bit of a
			else if ((a & 1) == 0)
			{
				/* Update prevLen to 0 (if next bit is 0)
				or currLen (if next bit is 1). */
				prevLen = (a & 2) == 0 ? 0 : currLen;

				// If two consecutively bits are 0
				// then currLen also will be 0.
				currLen = 0;
			}

			// Update maxLen if required
			maxLen = Math.max(prevLen + currLen, maxLen);

			// Remove last bit (Right shift)
			a >>= 1;
		}

		// We can always have a sequence of
		// at least one 1, this is flipped bit
		return maxLen + 1;
	}

	static byte sizeof()
	{
		byte sizeOfInteger = 8;
		return sizeOfInteger;
	}
	
	// Driver code
	public static void main(String[] args)
	{
		// input 1
		System.out.println(flipBit(13));

		// input 2
		System.out.println(flipBit(1775));

		// input 3
		System.out.println(flipBit(15));
	}
}

// Program for finding out majority element in an array 

class MajorityElement {
	/* Function to print Majority Element */
	void printMajority(int a[], int size)
	{
		/* Find the candidate for Majority*/
		int cand = findCandidate(a, size);

		/* Print the candidate if it is Majority*/
		if (isMajority(a, size, cand))
			System.out.println(" " + cand + " ");
		else
			System.out.println("No Majority Element");
	}

	/* Function to find the candidate for Majority */
	int findCandidate(int a[], int size)
	{
		int maj_index = 0, count = 1;
		int i;
		for (i = 1; i < size; i++) {
			if (a[maj_index] == a[i])
				count++;
			else
				count--;
			if (count == 0) {
				maj_index = i;
				count = 1;
			}
		}
		return a[maj_index];
	}

	/* Function to check if the candidate occurs more
	than n/2 times */
	boolean isMajority(int a[], int size, int cand)
	{
		int i, count = 0;
		for (i = 0; i < size; i++) {
			if (a[i] == cand)
				count++;
		}
		if (count > size / 2)
			return true;
		else
			return false;
	}

	/* Driver code */
	public static void main(String[] args)
	{
		MajorityElement majorelement
			= new MajorityElement();
		int a[] = new int[] { 1, 3, 3, 1, 2 };
		
		// Function call
		int size = a.length;
		majorelement.printMajority(a, size);
	}
}


// Java program to find maximum product subarray
import java.io.*;

class GFG {
	/* Returns the product of max product subarray.*/
	static int maxSubarrayProduct(int arr[])
	{
		// Initializing result
		int result = arr[0];
		int n = arr.length;

		for (int i = 0; i < n; i++) {
			int mul = arr[i];
			// traversing in current subarray
			for (int j = i + 1; j < n; j++) {
				// updating result every time to keep an eye
				// over the maximum product
				result = Math.max(result, mul);
				mul *= arr[j];
			}
			// updating the result for (n-1)th index.
			result = Math.max(result, mul);
		}
		return result;
	}

	// Driver Code
	public static void main(String[] args)
	{
		int arr[] = { 1, -2, -3, 0, 7, -8, -2 };
		System.out.println("Maximum Sub array product is "
						+ maxSubarrayProduct(arr));
	}
}

// java program to find maximum
// equilibrium sum.
import java.io.*;

class GFG {
	
	// Function to find maximum
	// equilibrium sum.
	static int findMaxSum(int []arr, int n)
	{
		int res = Integer.MIN_VALUE;
		
		for (int i = 0; i < n; i++)
		{
			int prefix_sum = arr[i];
			
			for (int j = 0; j < i; j++)
				prefix_sum += arr[j];
		
			int suffix_sum = arr[i];
			
			for (int j = n - 1; j > i; j--)
				suffix_sum += arr[j];
		
			if (prefix_sum == suffix_sum)
				res = Math.max(res, prefix_sum);
		}
		
		return res;
	}
	
	// Driver Code
	public static void main (String[] args)
	{
		int arr[] = {-2, 5, 3, 1, 2, 6, -4, 2 };
		int n = arr.length;
		System.out.println(findMaxSum(arr, n));
	}
}

// Java program to find maximum
// sum of hour glass in matrix
import java.io.*;

class GFG {
	
static int R = 5;
static int C = 5;

// Returns maximum sum of
// hour glass in ar[][]
static int findMaxSum(int [][]mat)
{
	if (R < 3 || C < 3){
		System.out.println("Not possible");
		System.exit(0);
	}

	// Here loop runs (R-2)*(C-2)
	// times considering different
	// top left cells of hour glasses.
	int max_sum = Integer.MIN_VALUE;
	for (int i = 0; i < R - 2; i++)
	{
		for (int j = 0; j < C - 2; j++)
		{
			// Considering mat[i][j] as top
			// left cell of hour glass.
			int sum = (mat[i][j] + mat[i][j + 1] +
					mat[i][j + 2]) + (mat[i + 1][j + 1]) +
					(mat[i + 2][j] + mat[i + 2][j + 1] +
					mat[i + 2][j + 2]);

			// If previous sum is less than
			// current sum then update
			// new sum in max_sum
			max_sum = Math.max(max_sum, sum);
		}
	}
	return max_sum;
}

	// Driver code
	static public void main (String[] args)
	{
		int [][]mat = {{1, 2, 3, 0, 0},
					{0, 0, 0, 0, 0},
					{2, 1, 4, 0, 0},
					{0, 0, 0, 0, 0},
					{1, 1, 0, 1, 0}};
		int res = findMaxSum(mat);
		System.out.println("Maximum sum of hour glass = "+ res);
	}
	
}

// Java program to swap two
// nibbles in a byte

class GFG {
	
static int swapNibbles(int x)
{
	return ((x & 0x0F) << 4 | (x & 0xF0) >> 4);
}

// Driver code
public static void main(String arg[])
{
	int x = 100;
	System.out.print(swapNibbles(x));
}
}